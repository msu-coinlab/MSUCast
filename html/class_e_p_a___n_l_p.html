<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MSU CAST EPA PROJECT: EPA_NLP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MSU CAST EPA PROJECT<span id="projectnumber">&#160;MSUCASTD01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_e_p_a___n_l_p.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_e_p_a___n_l_p-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">EPA_NLP Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>C++ Example NLP for interfacing a problem with IPOPT.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nlp_8hpp_source.html">nlp.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EPA_NLP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_e_p_a___n_l_p.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a116844a1d0ce952bd9a4016abba830d0" id="r_a116844a1d0ce952bd9a4016abba830d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116844a1d0ce952bd9a4016abba830d0">EPA_NLP</a> (const json &amp;base_scenario_json, const json &amp;scenario_json, const std::string &amp;path_out, int <a class="el" href="#a1739f20c48f1ef69613472c4f2bb27ab">pollutant_idx</a>)</td></tr>
<tr class="memdesc:a116844a1d0ce952bd9a4016abba830d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a116844a1d0ce952bd9a4016abba830d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9134e5504aed36cd3e635536a91418c4" id="r_a9134e5504aed36cd3e635536a91418c4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9134e5504aed36cd3e635536a91418c4">~EPA_NLP</a> ()</td></tr>
<tr class="memdesc:a9134e5504aed36cd3e635536a91418c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <br /></td></tr>
<tr class="separator:a9134e5504aed36cd3e635536a91418c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a201804d44ba547a0fe835a08ef015" id="r_a03a201804d44ba547a0fe835a08ef015"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a201804d44ba547a0fe835a08ef015">get_nlp_info</a> (Index &amp;n, Index &amp;m, Index &amp;nnz_jac_g, Index &amp;nnz_h_lag, IndexStyleEnum &amp;index_style)</td></tr>
<tr class="memdesc:a03a201804d44ba547a0fe835a08ef015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return some info about the NLP.  <br /></td></tr>
<tr class="separator:a03a201804d44ba547a0fe835a08ef015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fdf374323f1fd140ad986790efc9ce" id="r_aa1fdf374323f1fd140ad986790efc9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1fdf374323f1fd140ad986790efc9ce">write_files</a> (Index n, const Number *x, Index m, Number obj_value)</td></tr>
<tr class="memdesc:aa1fdf374323f1fd140ad986790efc9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to write files.  <br /></td></tr>
<tr class="separator:aa1fdf374323f1fd140ad986790efc9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a025ba37c917223e14324140d206eb" id="r_a84a025ba37c917223e14324140d206eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a025ba37c917223e14324140d206eb">save_files</a> (Index n, const Number *x)</td></tr>
<tr class="memdesc:a84a025ba37c917223e14324140d206eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to save files.  <br /></td></tr>
<tr class="separator:a84a025ba37c917223e14324140d206eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cfaad273e0a1db38a710ae54f1e794" id="r_a79cfaad273e0a1db38a710ae54f1e794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79cfaad273e0a1db38a710ae54f1e794">save_files2</a> (Index n, const Number *x)</td></tr>
<tr class="memdesc:a79cfaad273e0a1db38a710ae54f1e794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to save files (alternative).  <br /></td></tr>
<tr class="separator:a79cfaad273e0a1db38a710ae54f1e794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81101f05962cb86d216c67fe188f6d7" id="r_ac81101f05962cb86d216c67fe188f6d7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac81101f05962cb86d216c67fe188f6d7">write_land_json</a> (const std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt; &amp;lc_x, const std::string &amp;out_filename)</td></tr>
<tr class="memdesc:ac81101f05962cb86d216c67fe188f6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to write land JSON data.  <br /></td></tr>
<tr class="separator:ac81101f05962cb86d216c67fe188f6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647ebb709723dd3e4c079301cda60bbb" id="r_a647ebb709723dd3e4c079301cda60bbb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a647ebb709723dd3e4c079301cda60bbb">get_bounds_info</a> (Index n, Number *x_l, Number *x_u, Index m, Number *g_l, Number *g_u)</td></tr>
<tr class="memdesc:a647ebb709723dd3e4c079301cda60bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the bounds for my problem.  <br /></td></tr>
<tr class="separator:a647ebb709723dd3e4c079301cda60bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2936c1ba36e8c7b19f09590efab0a0a" id="r_ab2936c1ba36e8c7b19f09590efab0a0a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2936c1ba36e8c7b19f09590efab0a0a">get_starting_point</a> (Index n, bool init_x, Number *x, bool init_z, Number *z_L, Number *z_U, Index m, bool init_lambda, Number *lambda)</td></tr>
<tr class="memdesc:ab2936c1ba36e8c7b19f09590efab0a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the starting point for my problem.  <br /></td></tr>
<tr class="separator:ab2936c1ba36e8c7b19f09590efab0a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17a8c4e728ac84156a661f1795959c3" id="r_af17a8c4e728ac84156a661f1795959c3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af17a8c4e728ac84156a661f1795959c3">eval_f</a> (Index n, const Number *x, bool new_x, Number &amp;obj_value)</td></tr>
<tr class="memdesc:af17a8c4e728ac84156a661f1795959c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the objective value.  <br /></td></tr>
<tr class="separator:af17a8c4e728ac84156a661f1795959c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64438821cacbad299a3ec2c0d840277e" id="r_a64438821cacbad299a3ec2c0d840277e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64438821cacbad299a3ec2c0d840277e">eval_grad_f</a> (Index n, const Number *x, bool new_x, Number *grad_f)</td></tr>
<tr class="memdesc:a64438821cacbad299a3ec2c0d840277e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the gradient of the objective.  <br /></td></tr>
<tr class="separator:a64438821cacbad299a3ec2c0d840277e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9588099bc725de396e6cb2ac44039df" id="r_af9588099bc725de396e6cb2ac44039df"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9588099bc725de396e6cb2ac44039df">eval_g</a> (Index n, const Number *x, bool new_x, Index m, Number *g)</td></tr>
<tr class="memdesc:af9588099bc725de396e6cb2ac44039df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the constraint residuals.  <br /></td></tr>
<tr class="separator:af9588099bc725de396e6cb2ac44039df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a350617e473681c4119d123f923478a" id="r_a2a350617e473681c4119d123f923478a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a350617e473681c4119d123f923478a">eval_g_proxy</a> (Index n, const Number *x, bool new_x, Index m, Number *g, bool is_final)</td></tr>
<tr class="memdesc:a2a350617e473681c4119d123f923478a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the constraint residuals (alternative).  <br /></td></tr>
<tr class="separator:a2a350617e473681c4119d123f923478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7329feb3a399ab0f1883f2e4c35b1181" id="r_a7329feb3a399ab0f1883f2e4c35b1181"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7329feb3a399ab0f1883f2e4c35b1181">eval_jac_g</a> (Index n, const Number *x, bool new_x, Index m, Index nele_jac, Index *iRow, Index *jCol, Number *values)</td></tr>
<tr class="memdesc:a7329feb3a399ab0f1883f2e4c35b1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the structure of the Jacobian of the constraints.  <br /></td></tr>
<tr class="separator:a7329feb3a399ab0f1883f2e4c35b1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a0fc3852c4dd91e3a3ec5474dabc72" id="r_ae3a0fc3852c4dd91e3a3ec5474dabc72"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a0fc3852c4dd91e3a3ec5474dabc72">eval_h</a> (Index n, const Number *x, bool new_x, Number obj_factor, Index m, const Number *lambda, bool new_lambda, Index nele_hess, Index *iRow, Index *jCol, Number *values)</td></tr>
<tr class="memdesc:ae3a0fc3852c4dd91e3a3ec5474dabc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return the structure of the Hessian of the Lagrangian.  <br /></td></tr>
<tr class="separator:ae3a0fc3852c4dd91e3a3ec5474dabc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51793df302314c26d4d397e690cb1ba0" id="r_a51793df302314c26d4d397e690cb1ba0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51793df302314c26d4d397e690cb1ba0">finalize_solution</a> (SolverReturn status, Index n, const Number *x, const Number *z_L, const Number *z_U, Index m, const Number *g, const Number *lambda, Number obj_value, const IpoptData *ip_data, IpoptCalculatedQuantities *ip_cq)</td></tr>
<tr class="memdesc:a51793df302314c26d4d397e690cb1ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to finalize the solution.  <br /></td></tr>
<tr class="separator:a51793df302314c26d4d397e690cb1ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415d2b8cbedd5c30effbd9163b67a90c" id="r_a415d2b8cbedd5c30effbd9163b67a90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415d2b8cbedd5c30effbd9163b67a90c">update_reduction</a> (double reduction, int iteration)</td></tr>
<tr class="memdesc:a415d2b8cbedd5c30effbd9163b67a90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to update the reduction.  <br /></td></tr>
<tr class="separator:a415d2b8cbedd5c30effbd9163b67a90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5182f169e39080cb003e35517057214f" id="r_a5182f169e39080cb003e35517057214f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5182f169e39080cb003e35517057214f">get_scenario_data</a> ()</td></tr>
<tr class="memdesc:a5182f169e39080cb003e35517057214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to get the scenario data.  <br /></td></tr>
<tr class="separator:a5182f169e39080cb003e35517057214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776d2888183d888f5c36eafefcaad6b4" id="r_a776d2888183d888f5c36eafefcaad6b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a776d2888183d888f5c36eafefcaad6b4">get_uuid</a> ()</td></tr>
<tr class="memdesc:a776d2888183d888f5c36eafefcaad6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to get the UUID.  <br /></td></tr>
<tr class="separator:a776d2888183d888f5c36eafefcaad6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bde91cee32804998f834c1b4d8db15" id="r_a20bde91cee32804998f834c1b4d8db15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20bde91cee32804998f834c1b4d8db15">append_lc_x</a> (const std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt; &amp;lc_x)</td></tr>
<tr class="memdesc:a20bde91cee32804998f834c1b4d8db15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to append land data.  <br /></td></tr>
<tr class="separator:a20bde91cee32804998f834c1b4d8db15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14468523ef14d71d8643b3ee60e18dcb" id="r_a14468523ef14d71d8643b3ee60e18dcb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, int, int, int, int, int, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14468523ef14d71d8643b3ee60e18dcb">read_land</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a14468523ef14d71d8643b3ee60e18dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to read land data from a file.  <br /></td></tr>
<tr class="separator:a14468523ef14d71d8643b3ee60e18dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0f795cd3f81903458ab2b1320387a" id="r_ab8b0f795cd3f81903458ab2b1320387a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8b0f795cd3f81903458ab2b1320387a">write_land_barefoot</a> (const std::vector&lt; std::tuple&lt; int, int, int, int, int, int, double &gt; &gt; &amp;x, const std::string &amp;out_filename)</td></tr>
<tr class="memdesc:ab8b0f795cd3f81903458ab2b1320387a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to write land data to a file.  <br /></td></tr>
<tr class="separator:ab8b0f795cd3f81903458ab2b1320387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a13a18706355a8a792d1b8bc7afe432a9" id="r_a13a18706355a8a792d1b8bc7afe432a9"><td class="memItemLeft" align="right" valign="top"><a id="a13a18706355a8a792d1b8bc7afe432a9" name="a13a18706355a8a792d1b8bc7afe432a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>max_constr</b></td></tr>
<tr class="memdesc:a13a18706355a8a792d1b8bc7afe432a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum constraint value. <br /></td></tr>
<tr class="separator:a13a18706355a8a792d1b8bc7afe432a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0f5698c06f35d4eb420634cde296e4" id="r_aed0f5698c06f35d4eb420634cde296e4"><td class="memItemLeft" align="right" valign="top"><a id="aed0f5698c06f35d4eb420634cde296e4" name="aed0f5698c06f35d4eb420634cde296e4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>total_cost</b></td></tr>
<tr class="memdesc:aed0f5698c06f35d4eb420634cde296e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total cost of the problem. <br /></td></tr>
<tr class="separator:aed0f5698c06f35d4eb420634cde296e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f0c84a28172fb5b9ab34e877c15ca7" id="r_ab2f0c84a28172fb5b9ab34e877c15ca7"><td class="memItemLeft" align="right" valign="top"><a id="ab2f0c84a28172fb5b9ab34e877c15ca7" name="ab2f0c84a28172fb5b9ab34e877c15ca7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>total_acres</b></td></tr>
<tr class="memdesc:ab2f0c84a28172fb5b9ab34e877c15ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total acres of the problem. <br /></td></tr>
<tr class="separator:ab2f0c84a28172fb5b9ab34e877c15ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435ce04e07fbb4f498d97f00d6663d13" id="r_a435ce04e07fbb4f498d97f00d6663d13"><td class="memItemLeft" align="right" valign="top"><a id="a435ce04e07fbb4f498d97f00d6663d13" name="a435ce04e07fbb4f498d97f00d6663d13"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>status_result</b></td></tr>
<tr class="memdesc:a435ce04e07fbb4f498d97f00d6663d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status result of the problem. <br /></td></tr>
<tr class="separator:a435ce04e07fbb4f498d97f00d6663d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739f20c48f1ef69613472c4f2bb27ab" id="r_a1739f20c48f1ef69613472c4f2bb27ab"><td class="memItemLeft" align="right" valign="top"><a id="a1739f20c48f1ef69613472c4f2bb27ab" name="a1739f20c48f1ef69613472c4f2bb27ab"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>pollutant_idx</b></td></tr>
<tr class="memdesc:a1739f20c48f1ef69613472c4f2bb27ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the pollutant. <br /></td></tr>
<tr class="separator:a1739f20c48f1ef69613472c4f2bb27ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0946278756aecccb12ce7b5ba7641260" id="r_a0946278756aecccb12ce7b5ba7641260"><td class="memItemLeft" align="right" valign="top"><a id="a0946278756aecccb12ce7b5ba7641260" name="a0946278756aecccb12ce7b5ba7641260"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_content</b></td></tr>
<tr class="memdesc:a0946278756aecccb12ce7b5ba7641260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the problem has content. <br /></td></tr>
<tr class="separator:a0946278756aecccb12ce7b5ba7641260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods to block default compiler methods.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The compiler automatically generates the following three methods. Since the default compiler implementation is generally not what you want (for all but the most simple classes), we usually put the declarations of these methods in the private section and never implement them. This prevents the compiler from implementing an incorrect "default" behavior without us knowing. (See Scott Meyers book, "Effective C++") </p>
</td></tr>
<tr class="memitem:aa8b7c529f6dcfa2cbade68a0ac1930f8" id="r_aa8b7c529f6dcfa2cbade68a0ac1930f8"><td class="memItemLeft" align="right" valign="top"><a id="aa8b7c529f6dcfa2cbade68a0ac1930f8" name="aa8b7c529f6dcfa2cbade68a0ac1930f8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ef_size_</b></td></tr>
<tr class="separator:aa8b7c529f6dcfa2cbade68a0ac1930f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b4f61a1d121ad57b1762c80c41dc15" id="r_ad5b4f61a1d121ad57b1762c80c41dc15"><td class="memItemLeft" align="right" valign="top"><a id="ad5b4f61a1d121ad57b1762c80c41dc15" name="ad5b4f61a1d121ad57b1762c80c41dc15"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nvars_</b></td></tr>
<tr class="separator:ad5b4f61a1d121ad57b1762c80c41dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd143c915b0c4f905834c567017be93" id="r_a0dd143c915b0c4f905834c567017be93"><td class="memItemLeft" align="right" valign="top"><a id="a0dd143c915b0c4f905834c567017be93" name="a0dd143c915b0c4f905834c567017be93"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ncons_</b></td></tr>
<tr class="separator:a0dd143c915b0c4f905834c567017be93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b59da95c287bb26404da5672a07e15" id="r_a37b59da95c287bb26404da5672a07e15"><td class="memItemLeft" align="right" valign="top"><a id="a37b59da95c287bb26404da5672a07e15" name="a37b59da95c287bb26404da5672a07e15"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sum_load_invalid_</b></td></tr>
<tr class="separator:a37b59da95c287bb26404da5672a07e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44311aa987c7458f48f0cac3e57946c" id="r_ab44311aa987c7458f48f0cac3e57946c"><td class="memItemLeft" align="right" valign="top"><a id="ab44311aa987c7458f48f0cac3e57946c" name="ab44311aa987c7458f48f0cac3e57946c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sum_load_valid_</b></td></tr>
<tr class="separator:ab44311aa987c7458f48f0cac3e57946c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bd945892e5586f251f98ec5d64de43" id="r_a83bd945892e5586f251f98ec5d64de43"><td class="memItemLeft" align="right" valign="top"><a id="a83bd945892e5586f251f98ec5d64de43" name="a83bd945892e5586f251f98ec5d64de43"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ef_keys_</b></td></tr>
<tr class="separator:a83bd945892e5586f251f98ec5d64de43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d9e48d60091a97d6def16844c9297" id="r_aa12d9e48d60091a97d6def16844c9297"><td class="memItemLeft" align="right" valign="top"><a id="aa12d9e48d60091a97d6def16844c9297" name="aa12d9e48d60091a97d6def16844c9297"></a>
std::unordered_map&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>amount_</b></td></tr>
<tr class="separator:aa12d9e48d60091a97d6def16844c9297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af051ba8aca1e0903c915b83f8b45e417" id="r_af051ba8aca1e0903c915b83f8b45e417"><td class="memItemLeft" align="right" valign="top"><a id="af051ba8aca1e0903c915b83f8b45e417" name="af051ba8aca1e0903c915b83f8b45e417"></a>
std::unordered_map&lt; std::string, std::vector&lt; std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>efficiency_</b></td></tr>
<tr class="separator:af051ba8aca1e0903c915b83f8b45e417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61edb6472c93ed872ec5441baa37257a" id="r_a61edb6472c93ed872ec5441baa37257a"><td class="memItemLeft" align="right" valign="top"><a id="a61edb6472c93ed872ec5441baa37257a" name="a61edb6472c93ed872ec5441baa37257a"></a>
std::unordered_map&lt; std::string, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lrseg_</b></td></tr>
<tr class="separator:a61edb6472c93ed872ec5441baa37257a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69b26e92d13b4f5d4bf597054664054" id="r_ab69b26e92d13b4f5d4bf597054664054"><td class="memItemLeft" align="right" valign="top"><a id="ab69b26e92d13b4f5d4bf597054664054" name="ab69b26e92d13b4f5d4bf597054664054"></a>
std::unordered_map&lt; std::string, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eta_dict_</b></td></tr>
<tr class="separator:ab69b26e92d13b4f5d4bf597054664054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ed0cea5c4cd0bae12adca2157279b" id="r_a215ed0cea5c4cd0bae12adca2157279b"><td class="memItemLeft" align="right" valign="top"><a id="a215ed0cea5c4cd0bae12adca2157279b" name="a215ed0cea5c4cd0bae12adca2157279b"></a>
std::unordered_map&lt; std::string, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>phi_dict_</b></td></tr>
<tr class="separator:a215ed0cea5c4cd0bae12adca2157279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993eb8e270b198c8f18da36d8e381d95" id="r_a993eb8e270b198c8f18da36d8e381d95"><td class="memItemLeft" align="right" valign="top"><a id="a993eb8e270b198c8f18da36d8e381d95" name="a993eb8e270b198c8f18da36d8e381d95"></a>
std::unordered_map&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bmp_cost_</b></td></tr>
<tr class="separator:a993eb8e270b198c8f18da36d8e381d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59afbf3a978f14e220239f3ec01b26f" id="r_ac59afbf3a978f14e220239f3ec01b26f"><td class="memItemLeft" align="right" valign="top"><a id="ac59afbf3a978f14e220239f3ec01b26f" name="ac59afbf3a978f14e220239f3ec01b26f"></a>
std::unordered_map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>u_u_group_dict</b></td></tr>
<tr class="separator:ac59afbf3a978f14e220239f3ec01b26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97834daa42becb346ac351d8ad43a2" id="r_a1b97834daa42becb346ac351d8ad43a2"><td class="memItemLeft" align="right" valign="top"><a id="a1b97834daa42becb346ac351d8ad43a2" name="a1b97834daa42becb346ac351d8ad43a2"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>initial_x</b></td></tr>
<tr class="separator:a1b97834daa42becb346ac351d8ad43a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55b960c376da213fa12fbc7c304c358" id="r_ad55b960c376da213fa12fbc7c304c358"><td class="memItemLeft" align="right" valign="top"><a id="ad55b960c376da213fa12fbc7c304c358" name="ad55b960c376da213fa12fbc7c304c358"></a>
std::unordered_map&lt; int, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>limit_bmps_dict</b></td></tr>
<tr class="separator:ad55b960c376da213fa12fbc7c304c358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd82ece1b35a3ccaa5a0fb4e61b49a" id="r_a97fd82ece1b35a3ccaa5a0fb4e61b49a"><td class="memItemLeft" align="right" valign="top"><a id="a97fd82ece1b35a3ccaa5a0fb4e61b49a" name="a97fd82ece1b35a3ccaa5a0fb4e61b49a"></a>
std::unordered_map&lt; int, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>limit_alpha_dict</b></td></tr>
<tr class="separator:a97fd82ece1b35a3ccaa5a0fb4e61b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed55b9d9862140ddd6f9a845c3e3bb6" id="r_a0ed55b9d9862140ddd6f9a845c3e3bb6"><td class="memItemLeft" align="right" valign="top"><a id="a0ed55b9d9862140ddd6f9a845c3e3bb6" name="a0ed55b9d9862140ddd6f9a845c3e3bb6"></a>
std::unordered_map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>limit_vars_dict</b></td></tr>
<tr class="separator:a0ed55b9d9862140ddd6f9a845c3e3bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb20c7a2d4e712fe85833dbc8494c8a" id="r_a0bb20c7a2d4e712fe85833dbc8494c8a"><td class="memItemLeft" align="right" valign="top"><a id="a0bb20c7a2d4e712fe85833dbc8494c8a" name="a0bb20c7a2d4e712fe85833dbc8494c8a"></a>
std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ef_x_</b></td></tr>
<tr class="separator:a0bb20c7a2d4e712fe85833dbc8494c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadabb75a6050c1da5a38b7b62150483b" id="r_aadabb75a6050c1da5a38b7b62150483b"><td class="memItemLeft" align="right" valign="top"><a id="aadabb75a6050c1da5a38b7b62150483b" name="aadabb75a6050c1da5a38b7b62150483b"></a>
std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lc_x_</b></td></tr>
<tr class="separator:aadabb75a6050c1da5a38b7b62150483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8195f6be3bac70cccec713251be4fa9f" id="r_a8195f6be3bac70cccec713251be4fa9f"><td class="memItemLeft" align="right" valign="top"><a id="a8195f6be3bac70cccec713251be4fa9f" name="a8195f6be3bac70cccec713251be4fa9f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>uuid_</b></td></tr>
<tr class="separator:a8195f6be3bac70cccec713251be4fa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7cfd3cfd376629da22211182dbf5ac" id="r_a5d7cfd3cfd376629da22211182dbf5ac"><td class="memItemLeft" align="right" valign="top"><a id="a5d7cfd3cfd376629da22211182dbf5ac" name="a5d7cfd3cfd376629da22211182dbf5ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>current_iteration_</b></td></tr>
<tr class="separator:a5d7cfd3cfd376629da22211182dbf5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbe6ee5f1df34a5cc96eddc14807b33" id="r_a7bbe6ee5f1df34a5cc96eddc14807b33"><td class="memItemLeft" align="right" valign="top"><a id="a7bbe6ee5f1df34a5cc96eddc14807b33" name="a7bbe6ee5f1df34a5cc96eddc14807b33"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>scenario_data_</b></td></tr>
<tr class="separator:a7bbe6ee5f1df34a5cc96eddc14807b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7645554b023901fa5c1fc5062579c146" id="r_a7645554b023901fa5c1fc5062579c146"><td class="memItemLeft" align="right" valign="top"><a id="a7645554b023901fa5c1fc5062579c146" name="a7645554b023901fa5c1fc5062579c146"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>path_out_</b></td></tr>
<tr class="separator:a7645554b023901fa5c1fc5062579c146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80119ab1e1cae4d964739727f485fd6" id="r_ab80119ab1e1cae4d964739727f485fd6"><td class="memItemLeft" align="right" valign="top"><a id="ab80119ab1e1cae4d964739727f485fd6" name="ab80119ab1e1cae4d964739727f485fd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EPA_NLP</b> (const <a class="el" href="class_e_p_a___n_l_p.html">EPA_NLP</a> &amp;)</td></tr>
<tr class="separator:ab80119ab1e1cae4d964739727f485fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4033809c0d94d1e967ce13243c924a29" id="r_a4033809c0d94d1e967ce13243c924a29"><td class="memItemLeft" align="right" valign="top"><a id="a4033809c0d94d1e967ce13243c924a29" name="a4033809c0d94d1e967ce13243c924a29"></a>
<a class="el" href="class_e_p_a___n_l_p.html">EPA_NLP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_e_p_a___n_l_p.html">EPA_NLP</a> &amp;)</td></tr>
<tr class="separator:a4033809c0d94d1e967ce13243c924a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4cc0478518074cffb0102eb0ba8bb3" id="r_ada4cc0478518074cffb0102eb0ba8bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada4cc0478518074cffb0102eb0ba8bb3">filter_efficiency_keys</a> ()</td></tr>
<tr class="memdesc:ada4cc0478518074cffb0102eb0ba8bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the efficiency keys by removing invalid entries.  <br /></td></tr>
<tr class="separator:ada4cc0478518074cffb0102eb0ba8bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3231facf4e9cba66ebcfb083b8a72ca0" id="r_a3231facf4e9cba66ebcfb083b8a72ca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3231facf4e9cba66ebcfb083b8a72ca0">compute_efficiency_keys</a> ()</td></tr>
<tr class="memdesc:a3231facf4e9cba66ebcfb083b8a72ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and stores the efficiency keys.  <br /></td></tr>
<tr class="separator:a3231facf4e9cba66ebcfb083b8a72ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5922f1b46a4cbceaffcd8f72e30572e5" id="r_a5922f1b46a4cbceaffcd8f72e30572e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5922f1b46a4cbceaffcd8f72e30572e5">compute_efficiency_size</a> ()</td></tr>
<tr class="memdesc:a5922f1b46a4cbceaffcd8f72e30572e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of decision variables and constraints based on efficiency keys.  <br /></td></tr>
<tr class="separator:a5922f1b46a4cbceaffcd8f72e30572e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ddba603c73a800b92e759e439477f1" id="r_a09ddba603c73a800b92e759e439477f1"><td class="memItemLeft" align="right" valign="top"><a id="a09ddba603c73a800b92e759e439477f1" name="a09ddba603c73a800b92e759e439477f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_efficiency</b> ()</td></tr>
<tr class="separator:a09ddba603c73a800b92e759e439477f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b251845ea14f6b67658d834a93d78b4" id="r_a8b251845ea14f6b67658d834a93d78b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b251845ea14f6b67658d834a93d78b4">compute_eta</a> ()</td></tr>
<tr class="memdesc:a8b251845ea14f6b67658d834a93d78b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ETA values for each BMP.  <br /></td></tr>
<tr class="separator:a8b251845ea14f6b67658d834a93d78b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008ee6517cf695a4ee57d603018c136f" id="r_a008ee6517cf695a4ee57d603018c136f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008ee6517cf695a4ee57d603018c136f">load</a> (const json &amp;base_scenario_json, const json &amp;scenario_json)</td></tr>
<tr class="memdesc:a008ee6517cf695a4ee57d603018c136f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and initializes the <a class="el" href="class_e_p_a___n_l_p.html" title="C++ Example NLP for interfacing a problem with IPOPT.">EPA_NLP</a> instance using JSON scenario data.  <br /></td></tr>
<tr class="separator:a008ee6517cf695a4ee57d603018c136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b021bee02a4454a9f392ff70a23871" id="r_a14b021bee02a4454a9f392ff70a23871"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14b021bee02a4454a9f392ff70a23871">write_land</a> (const std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt; &amp;lc_x, const std::string &amp;out_filename)</td></tr>
<tr class="memdesc:a14b021bee02a4454a9f392ff70a23871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes land BMP data to a Parquet file.  <br /></td></tr>
<tr class="separator:a14b021bee02a4454a9f392ff70a23871"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ Example NLP for interfacing a problem with IPOPT. </p>
<p>This class provides an interface to IPOPT for solving a nonlinear programming problem. It defines the problem's objective function, constraints, and bounds. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a116844a1d0ce952bd9a4016abba830d0" name="a116844a1d0ce952bd9a4016abba830d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116844a1d0ce952bd9a4016abba830d0">&#9670;&#160;</a></span>EPA_NLP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPA_NLP::EPA_NLP </td>
          <td>(</td>
          <td class="paramtype">const json &amp;</td>          <td class="paramname"><span class="paramname"><em>base_scenario_json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json &amp;</td>          <td class="paramname"><span class="paramname"><em>scenario_json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pollutant_idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructor for the <a class="el" href="class_e_p_a___n_l_p.html" title="C++ Example NLP for interfacing a problem with IPOPT.">EPA_NLP</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_scenario_json</td><td>Base scenario JSON data. </td></tr>
    <tr><td class="paramname">scenario_json</td><td><a class="el" href="class_scenario.html" title="A class representing a scenario for optimization algorithms.">Scenario</a> JSON data. </td></tr>
    <tr><td class="paramname">path_out</td><td>Output path. </td></tr>
    <tr><td class="paramname">pollutant_idx</td><td>Index of the pollutant.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the <a class="el" href="class_e_p_a___n_l_p.html" title="C++ Example NLP for interfacing a problem with IPOPT.">EPA_NLP</a> instance with given scenario JSON data, output path, and pollutant index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_scenario_json</td><td>The JSON object containing the base scenario. </td></tr>
    <tr><td class="paramname">scenario_json</td><td>The JSON object containing scenario-specific parameters. </td></tr>
    <tr><td class="paramname">path_out</td><td>The output path where result files will be saved. </td></tr>
    <tr><td class="paramname">pollutant_idx</td><td>The index of the pollutant to optimize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9134e5504aed36cd3e635536a91418c4" name="a9134e5504aed36cd3e635536a91418c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9134e5504aed36cd3e635536a91418c4">&#9670;&#160;</a></span>~EPA_NLP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EPA_NLP::~EPA_NLP </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p>Destructor for the <a class="el" href="class_e_p_a___n_l_p.html" title="C++ Example NLP for interfacing a problem with IPOPT.">EPA_NLP</a> class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a20bde91cee32804998f834c1b4d8db15" name="a20bde91cee32804998f834c1b4d8db15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bde91cee32804998f834c1b4d8db15">&#9670;&#160;</a></span>append_lc_x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::append_lc_x </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lc_x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to append land data. </p>
<p>Appends land BMP data to the internal lc_x_ vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lc_x</td><td>Land data.</td></tr>
    <tr><td class="paramname">lc_x</td><td>A vector of tuples containing land BMP data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3231facf4e9cba66ebcfb083b8a72ca0" name="a3231facf4e9cba66ebcfb083b8a72ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3231facf4e9cba66ebcfb083b8a72ca0">&#9670;&#160;</a></span>compute_efficiency_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::compute_efficiency_keys </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and stores the efficiency keys. </p>
<p>This function extracts the keys from the efficiency_ map and sorts them. </p>

</div>
</div>
<a id="a5922f1b46a4cbceaffcd8f72e30572e5" name="a5922f1b46a4cbceaffcd8f72e30572e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5922f1b46a4cbceaffcd8f72e30572e5">&#9670;&#160;</a></span>compute_efficiency_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::compute_efficiency_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of decision variables and constraints based on efficiency keys. </p>
<p>This function iterates over the efficiency keys and counts the variables (each BMP) and adds one constraint per BMP group. </p>

</div>
</div>
<a id="a8b251845ea14f6b67658d834a93d78b4" name="a8b251845ea14f6b67658d834a93d78b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b251845ea14f6b67658d834a93d78b4">&#9670;&#160;</a></span>compute_eta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::compute_eta </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the ETA values for each BMP. </p>
<p>This function queries the Redis database for ETA values associated with each BMP and stores them in the eta_dict_ member variable. </p>

</div>
</div>
<a id="af17a8c4e728ac84156a661f1795959c3" name="af17a8c4e728ac84156a661f1795959c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17a8c4e728ac84156a661f1795959c3">&#9670;&#160;</a></span>eval_f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::eval_f </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number &amp;</td>          <td class="paramname"><span class="paramname"><em>obj_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the objective value. </p>
<p>Evaluates the objective function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating whether the variables have changed. </td></tr>
    <tr><td class="paramname">obj_value</td><td>Objective value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>Computes the total cost as the weighted sum of BMP costs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating if x is new. </td></tr>
    <tr><td class="paramname">obj_value</td><td>Reference to store the computed objective value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="af9588099bc725de396e6cb2ac44039df" name="af9588099bc725de396e6cb2ac44039df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9588099bc725de396e6cb2ac44039df">&#9670;&#160;</a></span>eval_g()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::eval_g </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the constraint residuals. </p>
<p>Evaluates the constraint functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating whether the variables have changed. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">g</td><td>Constraint residuals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>This function wraps the proxy evaluation function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating if x is new. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">g</td><td>Array to store constraint function values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="a2a350617e473681c4119d123f923478a" name="a2a350617e473681c4119d123f923478a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a350617e473681c4119d123f923478a">&#9670;&#160;</a></span>eval_g_proxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::eval_g_proxy </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_final</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the constraint residuals (alternative). </p>
<p>Proxy function for evaluating the constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating whether the variables have changed. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">g</td><td>Constraint residuals. </td></tr>
    <tr><td class="paramname">is_final</td><td>Flag indicating whether this is the final evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>Computes the pollutant load and other constraint-related values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating if x is new. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">g</td><td>Array to store constraint values. </td></tr>
    <tr><td class="paramname">is_final</td><td>Flag indicating if this is the final evaluation (affects output). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="a64438821cacbad299a3ec2c0d840277e" name="a64438821cacbad299a3ec2c0d840277e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64438821cacbad299a3ec2c0d840277e">&#9670;&#160;</a></span>eval_grad_f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::eval_grad_f </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>grad_f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the gradient of the objective. </p>
<p>Evaluates the gradient of the objective function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating whether the variables have changed. </td></tr>
    <tr><td class="paramname">grad_f</td><td>Gradient of the objective. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>Computes the gradient by differentiating the cost with respect to each decision variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating if x is new. </td></tr>
    <tr><td class="paramname">grad_f</td><td>Array to store the computed gradient values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="ae3a0fc3852c4dd91e3a3ec5474dabc72" name="ae3a0fc3852c4dd91e3a3ec5474dabc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a0fc3852c4dd91e3a3ec5474dabc72">&#9670;&#160;</a></span>eval_h()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::eval_h </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number</td>          <td class="paramname"><span class="paramname"><em>obj_factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>nele_hess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *</td>          <td class="paramname"><span class="paramname"><em>iRow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *</td>          <td class="paramname"><span class="paramname"><em>jCol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the structure of the Hessian of the Lagrangian. </p>
<p>Evaluates the Hessian of the Lagrangian.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating whether the variables have changed. </td></tr>
    <tr><td class="paramname">obj_factor</td><td>Objective function factor. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">lambda</td><td>Lagrange multipliers. </td></tr>
    <tr><td class="paramname">new_lambda</td><td>Flag indicating whether the Lagrange multipliers have changed. </td></tr>
    <tr><td class="paramname">nele_hess</td><td>Number of non-zero elements in the Hessian. </td></tr>
    <tr><td class="paramname">iRow</td><td>Row indices of the non-zero elements. </td></tr>
    <tr><td class="paramname">jCol</td><td>Column indices of the non-zero elements. </td></tr>
    <tr><td class="paramname">values</td><td>Values of the non-zero elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>This function is not fully implemented and returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating if x is new. </td></tr>
    <tr><td class="paramname">obj_factor</td><td>Factor multiplying the objective in the Hessian. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">lambda</td><td>Array of constraint multipliers. </td></tr>
    <tr><td class="paramname">new_lambda</td><td>Flag indicating if lambda is new. </td></tr>
    <tr><td class="paramname">nele_hess</td><td>Number of nonzero elements in the Hessian. </td></tr>
    <tr><td class="paramname">iRow</td><td>Array to store row indices of Hessian nonzeros. </td></tr>
    <tr><td class="paramname">jCol</td><td>Array to store column indices of Hessian nonzeros. </td></tr>
    <tr><td class="paramname">values</td><td>Array to store Hessian values (if not NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false (not implemented). </dd></dl>

</div>
</div>
<a id="a7329feb3a399ab0f1883f2e4c35b1181" name="a7329feb3a399ab0f1883f2e4c35b1181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7329feb3a399ab0f1883f2e4c35b1181">&#9670;&#160;</a></span>eval_jac_g()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::eval_jac_g </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>nele_jac</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *</td>          <td class="paramname"><span class="paramname"><em>iRow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *</td>          <td class="paramname"><span class="paramname"><em>jCol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the structure of the Jacobian of the constraints. </p>
<p>Evaluates the Jacobian of the constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating whether the variables have changed. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">nele_jac</td><td>Number of non-zero elements in the Jacobian. </td></tr>
    <tr><td class="paramname">iRow</td><td>Row indices of the non-zero elements. </td></tr>
    <tr><td class="paramname">jCol</td><td>Column indices of the non-zero elements. </td></tr>
    <tr><td class="paramname">values</td><td>Values of the non-zero elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>If the values pointer is NULL, the structure (row and column indices) of the Jacobian is returned. Otherwise, the Jacobian values are computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
    <tr><td class="paramname">new_x</td><td>Flag indicating if x is new. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">nele_jac</td><td>Number of nonzero elements in the Jacobian. </td></tr>
    <tr><td class="paramname">iRow</td><td>Array to store the row indices of the Jacobian. </td></tr>
    <tr><td class="paramname">jCol</td><td>Array to store the column indices of the Jacobian. </td></tr>
    <tr><td class="paramname">values</td><td>Array to store the Jacobian values (if not NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="ada4cc0478518074cffb0102eb0ba8bb3" name="ada4cc0478518074cffb0102eb0ba8bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4cc0478518074cffb0102eb0ba8bb3">&#9670;&#160;</a></span>filter_efficiency_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::filter_efficiency_keys </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters the efficiency keys by removing invalid entries. </p>
<p>This function connects to Redis to check for the existence of ETA entries and valid BMP costs. It removes keys that do not meet the required criteria. </p>

</div>
</div>
<a id="a51793df302314c26d4d397e690cb1ba0" name="a51793df302314c26d4d397e690cb1ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51793df302314c26d4d397e690cb1ba0">&#9670;&#160;</a></span>finalize_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::finalize_solution </td>
          <td>(</td>
          <td class="paramtype">SolverReturn</td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>z_L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>z_U</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number</td>          <td class="paramname"><span class="paramname"><em>obj_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IpoptData *</td>          <td class="paramname"><span class="paramname"><em>ip_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IpoptCalculatedQuantities *</td>          <td class="paramname"><span class="paramname"><em>ip_cq</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to finalize the solution. </p>
<p>Finalizes the solution after optimization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Solver return status. </td></tr>
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">z_L</td><td>Lower bounds for variables. </td></tr>
    <tr><td class="paramname">z_U</td><td>Upper bounds for variables. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">g</td><td>Constraint residuals. </td></tr>
    <tr><td class="paramname">lambda</td><td>Lagrange multipliers. </td></tr>
    <tr><td class="paramname">obj_value</td><td>Objective value. </td></tr>
    <tr><td class="paramname">ip_data</td><td>IPOPT data. </td></tr>
    <tr><td class="paramname">ip_cq</td><td>IPOPT calculated quantities.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes solution files in various formats and performs any final processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The solver return status. </td></tr>
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of final decision variable values. </td></tr>
    <tr><td class="paramname">z_L</td><td>Array of lower bound multipliers. </td></tr>
    <tr><td class="paramname">z_U</td><td>Array of upper bound multipliers. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">g</td><td>Array of final constraint values. </td></tr>
    <tr><td class="paramname">lambda</td><td>Array of final constraint multipliers. </td></tr>
    <tr><td class="paramname">obj_value</td><td>The final objective function value. </td></tr>
    <tr><td class="paramname">ip_data</td><td>Pointer to Ipopt data. </td></tr>
    <tr><td class="paramname">ip_cq</td><td>Pointer to Ipopt calculated quantities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a647ebb709723dd3e4c079301cda60bbb" name="a647ebb709723dd3e4c079301cda60bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647ebb709723dd3e4c079301cda60bbb">&#9670;&#160;</a></span>get_bounds_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::get_bounds_info </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>x_l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>x_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>g_l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>g_u</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the bounds for my problem. </p>
<p>Provides variable and constraint bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x_l</td><td>Lower bounds for variables. </td></tr>
    <tr><td class="paramname">x_u</td><td>Upper bounds for variables. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">g_l</td><td>Lower bounds for constraints. </td></tr>
    <tr><td class="paramname">g_u</td><td>Upper bounds for constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>Sets the lower and upper bounds for the decision variables and constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of variables. </td></tr>
    <tr><td class="paramname">x_l</td><td>Array of lower bounds for variables. </td></tr>
    <tr><td class="paramname">x_u</td><td>Array of upper bounds for variables. </td></tr>
    <tr><td class="paramname">m</td><td>The number of constraints. </td></tr>
    <tr><td class="paramname">g_l</td><td>Array of lower bounds for constraints. </td></tr>
    <tr><td class="paramname">g_u</td><td>Array of upper bounds for constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="a03a201804d44ba547a0fe835a08ef015" name="a03a201804d44ba547a0fe835a08ef015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a201804d44ba547a0fe835a08ef015">&#9670;&#160;</a></span>get_nlp_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::get_nlp_info </td>
          <td>(</td>
          <td class="paramtype">Index &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;</td>          <td class="paramname"><span class="paramname"><em>nnz_jac_g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;</td>          <td class="paramname"><span class="paramname"><em>nnz_h_lag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexStyleEnum &amp;</td>          <td class="paramname"><span class="paramname"><em>index_style</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return some info about the NLP. </p>
<p>Retrieves NLP problem dimensions and sparsity information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">nnz_jac_g</td><td>Number of non-zero elements in the Jacobian of the constraints. </td></tr>
    <tr><td class="paramname">nnz_h_lag</td><td>Number of non-zero elements in the Hessian of the Lagrangian. </td></tr>
    <tr><td class="paramname">index_style</td><td>Index style. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nnz_jac_g</td><td>Number of nonzeros in the Jacobian. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nnz_h_lag</td><td>Number of nonzeros in the Hessian of the Lagrangian. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index_style</td><td>The index style (C or Fortran style). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="a5182f169e39080cb003e35517057214f" name="a5182f169e39080cb003e35517057214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5182f169e39080cb003e35517057214f">&#9670;&#160;</a></span>get_scenario_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EPA_NLP::get_scenario_data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to get the scenario data. </p>
<p>Retrieves the scenario data string.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_scenario.html" title="A class representing a scenario for optimization algorithms.">Scenario</a> data as a string.</dd>
<dd>
The scenario data as a string. </dd></dl>

</div>
</div>
<a id="ab2936c1ba36e8c7b19f09590efab0a0a" name="ab2936c1ba36e8c7b19f09590efab0a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2936c1ba36e8c7b19f09590efab0a0a">&#9670;&#160;</a></span>get_starting_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EPA_NLP::get_starting_point </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>init_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>init_z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>z_L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>z_U</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>init_lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return the starting point for my problem. </p>
<p>Provides the starting point for the NLP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">init_x</td><td>Flag indicating whether to initialize variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">init_z</td><td>Flag indicating whether to initialize bounds. </td></tr>
    <tr><td class="paramname">z_L</td><td>Lower bounds for variables. </td></tr>
    <tr><td class="paramname">z_U</td><td>Upper bounds for variables. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">init_lambda</td><td>Flag indicating whether to initialize Lagrange multipliers. </td></tr>
    <tr><td class="paramname">lambda</td><td>Lagrange multipliers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise.</dd></dl>
<p>Initializes the decision variables with a greedy solution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of variables. </td></tr>
    <tr><td class="paramname">init_x</td><td>Boolean flag indicating if x should be initialized. </td></tr>
    <tr><td class="paramname">x</td><td>Array to store the starting point values. </td></tr>
    <tr><td class="paramname">init_z</td><td>Boolean flag indicating if z (bound multipliers) should be initialized. </td></tr>
    <tr><td class="paramname">z_L</td><td>Array for lower bound multipliers (unused). </td></tr>
    <tr><td class="paramname">z_U</td><td>Array for upper bound multipliers (unused). </td></tr>
    <tr><td class="paramname">m</td><td>The number of constraints. </td></tr>
    <tr><td class="paramname">init_lambda</td><td>Boolean flag indicating if lambda (constraint multipliers) should be initialized. </td></tr>
    <tr><td class="paramname">lambda</td><td>Array for constraint multipliers (unused). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="a776d2888183d888f5c36eafefcaad6b4" name="a776d2888183d888f5c36eafefcaad6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776d2888183d888f5c36eafefcaad6b4">&#9670;&#160;</a></span>get_uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EPA_NLP::get_uuid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to get the UUID. </p>
<p>Retrieves the unique identifier (UUID) for the current scenario.</p>
<dl class="section return"><dt>Returns</dt><dd>UUID as a string.</dd>
<dd>
The UUID string. </dd></dl>

</div>
</div>
<a id="a008ee6517cf695a4ee57d603018c136f" name="a008ee6517cf695a4ee57d603018c136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008ee6517cf695a4ee57d603018c136f">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::load </td>
          <td>(</td>
          <td class="paramtype">const json &amp;</td>          <td class="paramname"><span class="paramname"><em>base_scenario_json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json &amp;</td>          <td class="paramname"><span class="paramname"><em>scenario_json</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads and initializes the <a class="el" href="class_e_p_a___n_l_p.html" title="C++ Example NLP for interfacing a problem with IPOPT.">EPA_NLP</a> instance using JSON scenario data. </p>
<p>This function validates the presence of required keys, processes efficiency and BMP cost information, and sets up internal data structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_scenario_json</td><td>The base scenario JSON data. </td></tr>
    <tr><td class="paramname">scenario_json</td><td>The scenario-specific JSON data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14468523ef14d71d8643b3ee60e18dcb" name="a14468523ef14d71d8643b3ee60e18dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14468523ef14d71d8643b3ee60e18dcb">&#9670;&#160;</a></span>read_land()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, int, int, int, int, int, double &gt; &gt; EPA_NLP::read_land </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to read land data from a file. </p>
<p>Reads land data from a Parquet file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Land data as a vector of tuples.</dd></dl>
<p>Reads a Parquet file containing land BMP information and returns a vector of tuples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file path to the Parquet file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of tuples containing: AgencyId, StateId, BmpId, GeographyId, LoadSourceGroupId, UnitId, Amount. </dd></dl>

</div>
</div>
<a id="a84a025ba37c917223e14324140d206eb" name="a84a025ba37c917223e14324140d206eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a025ba37c917223e14324140d206eb">&#9670;&#160;</a></span>save_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::save_files </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to save files. </p>
<p>Saves the solution files in CSV and JSON formats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values.</td></tr>
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79cfaad273e0a1db38a710ae54f1e794" name="a79cfaad273e0a1db38a710ae54f1e794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cfaad273e0a1db38a710ae54f1e794">&#9670;&#160;</a></span>save_files2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::save_files2 </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to save files (alternative). </p>
<p>Saves internal solution data for further processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values.</td></tr>
  </table>
  </dd>
</dl>
<p>This function processes solution data into the ef_x_ vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of decision variable values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415d2b8cbedd5c30effbd9163b67a90c" name="a415d2b8cbedd5c30effbd9163b67a90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415d2b8cbedd5c30effbd9163b67a90c">&#9670;&#160;</a></span>update_reduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::update_reduction </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_constr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>current_iteration</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to update the reduction. </p>
<p>Updates the reduction constraint based on the current iteration and maximum constraint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduction</td><td>Reduction value. </td></tr>
    <tr><td class="paramname">iteration</td><td>Current iteration.</td></tr>
    <tr><td class="paramname">max_constr</td><td>The maximum constraint value. </td></tr>
    <tr><td class="paramname">current_iteration</td><td>The current iteration count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1fdf374323f1fd140ad986790efc9ce" name="aa1fdf374323f1fd140ad986790efc9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fdf374323f1fd140ad986790efc9ce">&#9670;&#160;</a></span>write_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EPA_NLP::write_files </td>
          <td>(</td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number</td>          <td class="paramname"><span class="paramname"><em>obj_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to write files. </p>
<p>Writes the solution to various output files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Variable values. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">obj_value</td><td>Objective value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function outputs the final solution (objective value, constraints, BMP selections) to CSV, JSON, and Parquet files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of variables. </td></tr>
    <tr><td class="paramname">x</td><td>Array of final decision variable values. </td></tr>
    <tr><td class="paramname">m</td><td>Number of constraints. </td></tr>
    <tr><td class="paramname">obj_value</td><td>The final objective function value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14b021bee02a4454a9f392ff70a23871" name="a14b021bee02a4454a9f392ff70a23871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b021bee02a4454a9f392ff70a23871">&#9670;&#160;</a></span>write_land()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int EPA_NLP::write_land </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lc_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>out_filename</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes land BMP data to a Parquet file. </p>
<p>This function converts the input tuple vector into the required format and calls write_land_barefoot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lc_x</td><td>A vector of tuples containing land BMP data. </td></tr>
    <tr><td class="paramname">out_filename</td><td>The output file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of records written. </dd></dl>

</div>
</div>
<a id="ab8b0f795cd3f81903458ab2b1320387a" name="ab8b0f795cd3f81903458ab2b1320387a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b0f795cd3f81903458ab2b1320387a">&#9670;&#160;</a></span>write_land_barefoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EPA_NLP::write_land_barefoot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; int, int, int, int, int, int, double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>out_filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to write land data to a file. </p>
<p>Writes land data to a Parquet file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Land data. </td></tr>
    <tr><td class="paramname">out_filename</td><td>Output file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written.</dd></dl>
<p>This function writes a vector of land data tuples to a Parquet file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A vector of tuples representing land data. </td></tr>
    <tr><td class="paramname">out_filename</td><td>The output file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of records written. </dd></dl>

</div>
</div>
<a id="ac81101f05962cb86d216c67fe188f6d7" name="ac81101f05962cb86d216c67fe188f6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81101f05962cb86d216c67fe188f6d7">&#9670;&#160;</a></span>write_land_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EPA_NLP::write_land_json </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; int, int, int, int, double, int, int, int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lc_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>out_filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to write land JSON data. </p>
<p>Writes land data to a JSON file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lc_x</td><td>Land data. </td></tr>
    <tr><td class="paramname">out_filename</td><td>Output file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written.</dd></dl>
<p>Converts the land BMP data into a JSON object and writes it to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lc_x</td><td>A vector of tuples containing land BMP data. </td></tr>
    <tr><td class="paramname">out_filename</td><td>The output file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of records processed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>eps_cnstr/<a class="el" href="nlp_8hpp_source.html">nlp.hpp</a></li>
<li>eps_cnstr/<a class="el" href="nlp_8cpp.html">nlp.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_e_p_a___n_l_p.html">EPA_NLP</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
